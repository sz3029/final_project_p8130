---
title: "Interaction & Diagnostic"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include = FALSE, message = FALSE}
library(tidyverse)
library(dplyr)
library(MASS)
library(ggplot2)
library(GGally)
library(leaps)
library(lattice)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)

set.seed(1)
```

## Data upload

```{r, message = FALSE}
crime_df = 
  read_csv("cdi.csv") %>% 
  mutate(
    region = factor(region),
    pop_density = pop / area,
    crm_1000 = 1000 * crimes / pop
  ) %>% 
  dplyr::select(-crimes, -id, -area, -pop) %>% 
  dplyr::select(crm_1000, everything())
```

## EDA
```{r}
crime_state = crime_df %>% 
  group_by(state) %>% 
  summarize(crime_rate = mean(crm_1000))

crime_state[order(-rank(crime_state$crime_rate)),] %>% 
  knitr::kable()

crime_state %>% 
  ggplot(aes(x=reorder(state,crime_rate),y=crime_rate, fill = crime_rate)) + 
  geom_bar(stat ='identity')+
  coord_flip() + 
  theme_grey() + 
  labs(title = 'Ranking of Counties by crime rate', y ='Crime rate',x ='States') +
  theme(plot.title = element_text(hjust = 0.5,size = 14), axis.text=element_text(size=6.5))
```

```{r}
temp <- crime_df %>%
  dplyr::select(-cty, -state)
mult.fit = lm(crm_1000 ~ ., data = temp)
mult.back = step(mult.fit, direction = "backward")
```



## Models
```{r}
model_backward = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density, data = crime_df)

model_forward = lm(crm_1000 ~ pop18 + pop65 + docs + beds + hsgrad + 
    bagrad + poverty + unemp + pcincome + totalinc + region + 
    pop_density, data = crime_df)

model_stepwise = lm(crm_1000 ~ pop18 + docs + beds + hsgrad + bagrad + 
    poverty + pcincome + totalinc + pop_density, data = crime_df)
```
Proceed with backward

## Cp
```{r}
reg = regsubsets(crm_1000 ~ pop18 + docs + beds + hsgrad + bagrad + 
    poverty + pcincome + totalinc + pop_density, data = crime_df)
rs = summary(reg)

plot(2:9, rs$cp, xlab="No of parameters", ylab="Cp Statistic")
abline(0,1)

plot(2:9, rs$adjr2, xlab="No of parameters", ylab="Adj R2")
```

## Partial ANOVA model_select

```{r}
#linear regression model with full predictors
fit_no_inte = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + docs + region + pop_density, data = crime_df)

summary(fit_no_inte)
```

Next using partial ANOVA to test whether large model is superior

```{r}
# no pop_density
fit_1 = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + docs + region, data = crime_df)
summary(fit_1)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_1, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no region
fit_no_inte = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + docs + pop_density + region , data = crime_df)
fit_2 = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + docs + pop_density, data = crime_df)
summary(fit_2)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_2, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no docs
fit_no_inte = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + region + pop_density + docs, data = crime_df)
fit_3 = lm(crm_1000 ~ totalinc + poverty + hsgrad + beds + region + pop_density, data = crime_df)
summary(fit_3)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_3, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no beds
fit_no_inte = lm(crm_1000 ~ totalinc + poverty + hsgrad + region + pop_density + docs+ beds, data = crime_df)
fit_4 = lm(crm_1000 ~ totalinc + poverty + hsgrad + region + pop_density + docs, data = crime_df)
summary(fit_4)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_4, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no hsgrad
fit_no_inte = lm(crm_1000 ~ totalinc + poverty + region + pop_density + docs+ beds + hsgrad , data = crime_df)
fit_5 = lm(crm_1000 ~ totalinc + poverty + region + pop_density + docs + beds, data = crime_df)
summary(fit_5)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_5, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no poverty
fit_no_inte = lm(crm_1000 ~ totalinc + region + pop_density + docs+ beds + hsgrad + poverty , data = crime_df)
fit_6 = lm(crm_1000 ~ totalinc + region + pop_density + docs + beds + hsgrad, data = crime_df)
summary(fit_6)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_6, fit_no_inte)
```

Reject H0, large model is superior

```{r}
# no totalinc
fit_no_inte = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + totalinc, data = crime_df)
fit_7 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density, data = crime_df)
summary(fit_7)

# compare nested (small vs large) models
# Ho: smaller model is defensible
anova(fit_7, fit_no_inte)
```

Fail to reject H0, large model is not superior, then we do not include total person income.

## Potential Interaction

```{r}
coplot(crm_1000 ~ poverty | docs, data = crime_df,
       number = 4, rows = 1,
       panel = panel.smooth)

coplot(crm_1000 ~ docs | region, data = crime_df,
       number = 4, rows = 1,
       panel = panel.smooth)

coplot(crm_1000 ~ beds | docs, data = crime_df,
       number = 4, rows = 1,
       panel = panel.smooth)

coplot(crm_1000 ~ beds | pcincome, data = crime_df,
       number = 4, rows = 1,
       panel = panel.smooth)
```

### model_select

Build model with interaction
```{r}
select_1 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + poverty*docs + docs*region + beds*docs, data = crime_df)

summary(select_1)
```

Test if three interaction term is significant

```{r}
select_2 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + poverty*docs + hsgrad*region, data = crime_df)

anova(select_2, select_1)
```

Reject H0

```{r}
select_3 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + poverty*docs + beds*docs, data = crime_df)

anova(select_3, select_1)
```

Reject H0

```{r}
select_4 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + docs*region + beds*docs, data = crime_df)

anova(select_4, select_1)
```

Fail to reject H0, use the simple regression model

### model_backward
```{r}
backward_1 = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density + poverty*docs + docs*region + beds*docs + beds*pcincome, data = crime_df)
summary(backward_1)
```

Test if interaction term is significant

```{r}
backward_2 = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density + docs*region + beds*docs + beds*pcincome, data = crime_df)

anova(backward_2, backward_1)
```

Fail to reject, keep simpler

```{r}
backward_3 = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density + beds*docs + beds*pcincome, data = crime_df)

anova(backward_3, backward_1)
```

Fail to reject, keep simpler

```{r}
# docs and totalinc
backward_4 = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density + beds*docs, data = crime_df)

anova(backward_4, backward_1)
```

Reject H0

## Candidate models

Thus the four candidate regression model should be:
```{r}
model_1 = lm(crm_1000 ~ poverty + hsgrad + beds + docs + region + pop_density + docs*region + beds*docs, data = crime_df)

model_2 = lm(crm_1000 ~ pop18 + docs + beds + poverty + pcincome + 
    region + pop_density + beds*docs + beds*pcincome, data = crime_df)
```

## Model Diagonistic

residual vs fitted plot
```{r}
par(mfrow = c(1,2))
plot(model_1, which = 1)
plot(model_2, which = 1)
```

QQ plot
```{r}
par(mfrow = c(1,2))
plot(model_1, which = 2)
plot(model_2, which = 2)
```

Scale-Location
```{r}
par(mfrow = c(1,2))
plot(model_1, which = 3)
plot(model_2, which = 3)
```

Residual
```{r}
par(mfrow = c(1,2))
plot(model_1, which = 5)
plot(model_2, which = 5)
```

## Boxcox transformation
```{r}
par(mfrow = c(1,2))
bc <- boxcox(model_1, lambda = seq(-5, 5, by = 0.25))
boxcox(model_2, lambda = seq(-5, 5, by = 0.25))
```

```{r}
lambda <- bc$x[which.max(bc$y)]

BCTransform <- function(y, lambda=0) {
    if (lambda == 0L) { log(y) }
    else { (y^lambda - 1) / lambda }
}

BCTransformInverse <- function(yt, lambda=0) {
    if (lambda == 0L) { exp(yt) }
    else { exp(log(1 + lambda * yt)/lambda) }
}

crime_df$crm.bc <- BCTransform(crime_df$crm_1000, lambda)
model_bc = lm(crm.bc ~ poverty + hsgrad + beds + docs + region + pop_density + beds * docs + beds * totalinc, data = crime_df)

par(mfrow = c(1,2))
plot(model_1, which = 2)
plot(model_bc, which = 2)
```






